# üîç CODE REVIEW PREPARATION - LifeCompanion

## √âpreuve RNCP36146 (20 minutes)

---

## üìã **FORMAT √âPREUVE**

### **Modalit√©s**

- **Dur√©e** : 20 minutes individuel
- **Base de code** : GitHub LifeCompanion
- **Jury** : S√©lection al√©atoire commits + 1 bug personnel

### **Objectifs √âvaluation**

- ‚úÖ Qualit√© code et respect standards
- ‚úÖ Compr√©hension du code produit
- ‚úÖ Capacit√© d'am√©lioration base de code
- ‚úÖ R√©solution bugs et debugging

---

## üêõ **PORTION 1 : BUG R√âSOLU S√âLECTIONN√â**

### **Bug Choisi : MQTT Connection Timeout**

#### **Contexte Probl√®me**

```yaml
Sympt√¥mes:
  - Timeout connexions MQTT apr√®s 30 secondes
  - Perte donn√©es capteurs critiques
  - Logs: 'Connection refused after 30s'
  - Impact: 15% perte donn√©es IoT

Environnement:
  - Laravel 10 + ReactPHP MQTT Client
  - Eclipse Mosquitto broker
  - R√©seau avec latence variable (50-200ms)
```

#### **Code Probl√©matique (AVANT)**

```php
<?php
// app/Services/IoT/MqttConnectionService.php

class MqttConnectionService
{
    private MqttClient $client;

    public function connect(): void
    {
        $this->client = new MqttClient(
            config('mqtt.host'),
            config('mqtt.port'),
            config('mqtt.client_id')
        );

        // ‚ùå PROBL√àME: Keep-alive trop court
        $this->client->connect(true, 30); // Timeout 30s seulement

        // ‚ùå PROBL√àME: Pas de retry automatique
        $this->client->onConnectionLost(function() {
            logger()->error('MQTT connection lost');
            // Pas de reconnexion automatique
        });
    }

    public function subscribe(string $topic): void
    {
        // ‚ùå PROBL√àME: Pas de v√©rification √©tat connexion
        $this->client->subscribe($topic, function($message) {
            $this->handleMessage($message);
        });
    }
}
```

#### **Analyse du Probl√®me**

```markdown
## Causes Identifi√©es

1. **Keep-alive insuffisant** (30s)

   - R√©seau instable avec pics latence
   - Broker consid√®re client d√©connect√© pr√©matur√©ment

2. **Absence retry automatique**

   - Perte d√©finitive connexion sur timeout
   - Pas de strat√©gie reconnexion

3. **Pas de health check**
   - Impossible d√©tecter connexions zombies
   - Accumulation connexions mortes

## Impact M√©tier

- **15% perte donn√©es** IoT critiques
- **Alertes manqu√©es** pour utilisateurs
- **D√©gradation exp√©rience** utilisateur
```

#### **Code Corrig√© (APR√àS)**

```php
<?php
// app/Services/IoT/MqttConnectionService.php

declare(strict_types=1);

class MqttConnectionService
{
    private MqttClient $client;
    private bool $isConnected = false;
    private int $reconnectAttempts = 0;
    private const MAX_RECONNECT_ATTEMPTS = 5;

    public function connect(): void
    {
        $this->client = new MqttClient(
            config('mqtt.host'),
            config('mqtt.port'),
            config('mqtt.client_id')
        );

        // ‚úÖ SOLUTION: Keep-alive augment√©
        $this->client->setKeepAlive(120); // 2 minutes

        // ‚úÖ SOLUTION: Retry avec backoff exponentiel
        $this->client->setReconnectDelay(5, 60, true);

        // ‚úÖ SOLUTION: Gestion √©v√©nements connexion
        $this->client->onConnect(function() {
            $this->isConnected = true;
            $this->reconnectAttempts = 0;
            logger()->info('MQTT connected successfully');
        });

        $this->client->onConnectionLost(function() {
            $this->isConnected = false;
            $this->handleConnectionLost();
        });

        // ‚úÖ SOLUTION: Timeout connexion augment√©
        $this->client->connect(true, 120);

        // ‚úÖ SOLUTION: Health check p√©riodique
        $this->startHealthCheck();
    }

    private function handleConnectionLost(): void
    {
        $this->reconnectAttempts++;

        logger()->warning('MQTT connection lost', [
            'attempt' => $this->reconnectAttempts,
            'max_attempts' => self::MAX_RECONNECT_ATTEMPTS
        ]);

        if ($this->reconnectAttempts < self::MAX_RECONNECT_ATTEMPTS) {
            // Retry automatique g√©r√© par setReconnectDelay
            return;
        }

        // ‚úÖ SOLUTION: Notification admin si √©chec d√©finitif
        $this->notifyAdministrators();
    }

    private function startHealthCheck(): void
    {
        // ‚úÖ SOLUTION: Ping toutes les 60s
        Timer::addPeriodicTimer(60, function() {
            if (!$this->client->ping()) {
                logger()->warning('MQTT ping failed, reconnecting...');
                $this->client->reconnect();
            }
        });
    }

    public function subscribe(string $topic): void
    {
        // ‚úÖ SOLUTION: V√©rification √©tat connexion
        if (!$this->isConnected) {
            throw new MqttConnectionException('Not connected to MQTT broker');
        }

        $this->client->subscribe($topic, function($message) {
            try {
                $this->handleMessage($message);
            } catch (Exception $e) {
                logger()->error('Error handling MQTT message', [
                    'topic' => $topic,
                    'error' => $e->getMessage()
                ]);
            }
        });
    }

    private function notifyAdministrators(): void
    {
        // Notification Slack/Email admin
        Notification::route('slack', config('alerts.slack_webhook'))
            ->notify(new MqttConnectionFailedNotification($this->reconnectAttempts));
    }
}
```

#### **Tests Unitaires Ajout√©s**

```php
<?php
// tests/Unit/Services/IoT/MqttConnectionServiceTest.php

class MqttConnectionServiceTest extends TestCase
{
    /** @test */
    public function it_handles_connection_timeout_gracefully(): void
    {
        // Arrange
        $mockClient = Mockery::mock(MqttClient::class);
        $mockClient->shouldReceive('setKeepAlive')->with(120);
        $mockClient->shouldReceive('setReconnectDelay')->with(5, 60, true);
        $mockClient->shouldReceive('connect')->with(true, 120);

        // Act
        $service = new MqttConnectionService();
        $service->connect();

        // Assert
        $this->assertTrue(true); // Connection configur√©e correctement
    }

    /** @test */
    public function it_throws_exception_when_subscribing_without_connection(): void
    {
        // Arrange
        $service = new MqttConnectionService();

        // Act & Assert
        $this->expectException(MqttConnectionException::class);
        $service->subscribe('sensors/temperature');
    }
}
```

#### **R√©sultats Mesur√©s**

```yaml
Avant Fix:
  - Perte donn√©es: 15%
  - Reconnexions manuelles: 5-10/jour
  - Uptime connexion: 85%

Apr√®s Fix:
  - Perte donn√©es: <1%
  - Reconnexions automatiques: 99% succ√®s
  - Uptime connexion: 99.8%
  - Latence moyenne: -20ms (moins de timeouts)
```

---

## üíª **PORTION 2 : COMMITS REPR√âSENTATIFS**

### **Commit 1 : Architecture Clean - Repository Pattern**

```bash
commit: feat(architecture): Implement Repository pattern for IoT data
hash: abc123f4567890
```

```php
<?php
// app/Domain/IoT/Repositories/SensorReadingRepositoryInterface.php

declare(strict_types=1);

namespace App\Domain\IoT\Repositories;

use App\Domain\IoT\Entities\SensorReading;
use Carbon\Carbon;
use Illuminate\Support\Collection;

/**
 * Interface pour l'acc√®s aux donn√©es des lectures capteurs
 * Respecte les principes SOLID et Clean Architecture
 */
interface SensorReadingRepositoryInterface
{
    /**
     * Stocke une nouvelle lecture de capteur
     */
    public function store(SensorReading $reading): SensorReading;

    /**
     * R√©cup√®re les lectures d'un device avec filtrage temporel
     */
    public function findByDevice(
        string $deviceId,
        ?Carbon $from = null,
        ?Carbon $to = null
    ): Collection;

    /**
     * Obtient la derni√®re lecture d'un capteur sp√©cifique
     */
    public function getLatestReading(
        string $deviceId,
        string $sensorType
    ): ?SensorReading;

    /**
     * Statistiques agr√©g√©es pour analytics
     */
    public function getAggregatedStats(
        string $deviceId,
        string $sensorType,
        string $interval = '1 hour'
    ): Collection;
}
```

```php
<?php
// app/Infrastructure/Repositories/EloquentSensorReadingRepository.php

declare(strict_types=1);

namespace App\Infrastructure\Repositories;

use App\Domain\IoT\Entities\SensorReading;
use App\Domain\IoT\Repositories\SensorReadingRepositoryInterface;
use App\Infrastructure\Models\SensorReadingModel;
use Carbon\Carbon;
use Illuminate\Support\Collection;

/**
 * Impl√©mentation Eloquent du repository SensorReading
 * S√©pare la logique m√©tier de la persistance
 */
final class EloquentSensorReadingRepository implements SensorReadingRepositoryInterface
{
    public function store(SensorReading $reading): SensorReading
    {
        $model = SensorReadingModel::create([
            'device_id' => $reading->deviceId,
            'sensor_type' => $reading->sensorType->value,
            'value' => $reading->value,
            'unit' => $reading->unit,
            'timestamp' => $reading->timestamp,
            'metadata' => json_encode($reading->metadata)
        ]);

        return $this->toDomainEntity($model);
    }

    public function findByDevice(
        string $deviceId,
        ?Carbon $from = null,
        ?Carbon $to = null
    ): Collection {
        $query = SensorReadingModel::where('device_id', $deviceId)
            ->orderBy('timestamp', 'desc');

        if ($from) {
            $query->where('timestamp', '>=', $from);
        }

        if ($to) {
            $query->where('timestamp', '<=', $to);
        }

        return $query->get()->map(fn($model) => $this->toDomainEntity($model));
    }

    public function getLatestReading(string $deviceId, string $sensorType): ?SensorReading
    {
        $model = SensorReadingModel::where('device_id', $deviceId)
            ->where('sensor_type', $sensorType)
            ->latest('timestamp')
            ->first();

        return $model ? $this->toDomainEntity($model) : null;
    }

    public function getAggregatedStats(
        string $deviceId,
        string $sensorType,
        string $interval = '1 hour'
    ): Collection {
        // Utilisation TimescaleDB pour performance
        return collect(DB::select("
            SELECT
                time_bucket(?, timestamp) as bucket,
                AVG(value) as avg_value,
                MIN(value) as min_value,
                MAX(value) as max_value,
                COUNT(*) as reading_count
            FROM sensor_readings
            WHERE device_id = ? AND sensor_type = ?
            GROUP BY bucket
            ORDER BY bucket DESC
        ", [$interval, $deviceId, $sensorType]));
    }

    /**
     * Convertit le mod√®le Eloquent en entit√© domaine
     */
    private function toDomainEntity(SensorReadingModel $model): SensorReading
    {
        return new SensorReading(
            deviceId: $model->device_id,
            sensorType: SensorType::from($model->sensor_type),
            value: $model->value,
            unit: $model->unit,
            timestamp: $model->timestamp,
            metadata: json_decode($model->metadata, true) ?? []
        );
    }
}
```

### **Commit 2 : Event-Driven Architecture**

```bash
commit: feat(events): Add event-driven ML classification pipeline
hash: def456g7890123
```

```php
<?php
// app/Domain/IoT/Events/SensorDataReceived.php

declare(strict_types=1);

namespace App\Domain\IoT\Events;

use App\Domain\IoT\Entities\SensorReading;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

/**
 * √âv√©nement d√©clench√© lors de la r√©ception de donn√©es capteur
 * Permet le d√©couplage entre collecte et traitement
 */
final class SensorDataReceived
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public readonly SensorReading $reading
    ) {}
}
```

```php
<?php
// app/Application/Listeners/TriggerActivityClassification.php

declare(strict_types=1);

namespace App\Application\Listeners;

use App\Domain\IoT\Events\SensorDataReceived;
use App\Application\Jobs\ClassifyActivityJob;

/**
 * Listener qui d√©clenche la classification ML
 * Traitement asynchrone pour √©viter blocage API
 */
final class TriggerActivityClassification
{
    public function handle(SensorDataReceived $event): void
    {
        // Classification asynchrone via queue
        ClassifyActivityJob::dispatch($event->reading)
            ->onQueue('ml-processing')
            ->delay(now()->addSeconds(5)); // Petit d√©lai pour agr√©gation
    }
}
```

---

## üéØ **POINTS FORTS √Ä METTRE EN AVANT**

### **Qualit√© Code**

- ‚úÖ **PSR-12** : Standards PHP respect√©s
- ‚úÖ **Type Safety** : declare(strict_types=1) partout
- ‚úÖ **SOLID Principles** : Interfaces, injection d√©pendances
- ‚úÖ **Clean Architecture** : S√©paration Domain/Infrastructure
- ‚úÖ **Documentation** : PHPDoc complet

### **Patterns Utilis√©s**

- ‚úÖ **Repository Pattern** : Abstraction acc√®s donn√©es
- ‚úÖ **Event-Driven** : D√©couplage services
- ‚úÖ **Service Layer** : Logique m√©tier encapsul√©e
- ‚úÖ **DTO/Value Objects** : Immutabilit√© donn√©es
- ‚úÖ **Factory Pattern** : Cr√©ation objets complexes

### **Performance & Scalabilit√©**

- ‚úÖ **TimescaleDB** : Optimisation s√©ries temporelles
- ‚úÖ **Queue Jobs** : Traitement asynchrone
- ‚úÖ **Caching** : Redis pour donn√©es fr√©quentes
- ‚úÖ **Database Indexing** : Requ√™tes optimis√©es

---

## ü§î **AM√âLIORATIONS POSSIBLES**

### **S√©curit√©**

- üîí **Input Validation** : Sch√©mas JSON plus stricts
- üîí **Rate Limiting** : Protection API endpoints
- üîí **Audit Logging** : Tra√ßabilit√© actions utilisateurs

### **Monitoring**

- üìä **Application Metrics** : Prometheus custom metrics
- üìä **Error Tracking** : Sentry int√©gration
- üìä **Performance APM** : New Relic monitoring

### **Tests**

- üß™ **Integration Tests** : End-to-end scenarios
- üß™ **Load Testing** : Performance sous charge
- üß™ **Mutation Testing** : Qualit√© tests unitaires

---

## üí° **R√âPONSES AUX QUESTIONS PROBABLES**

### **"Pourquoi Clean Architecture ?"**

- **Maintenabilit√©** : Logique m√©tier ind√©pendante framework
- **Testabilit√©** : Mocking facile des d√©pendances
- **√âvolutivit√©** : Changement infrastructure sans impact m√©tier

### **"Comment g√©rez-vous la performance ?"**

- **Database** : Index composites, TimescaleDB pour IoT
- **Caching** : Redis multi-niveaux (query, session, application)
- **Queue** : Jobs asynchrones pour t√¢ches lourdes (ML)

### **"Gestion des erreurs ?"**

- **Custom Exceptions** : Types d'erreurs sp√©cifiques
- **Logging Structur√©** : Context et correlation IDs
- **Circuit Breaker** : Protection services externes

---

**Pr√©paration Code Review RNCP36146**  
**Dur√©e : 20 minutes**  
**Base de code : GitHub LifeCompanion**
